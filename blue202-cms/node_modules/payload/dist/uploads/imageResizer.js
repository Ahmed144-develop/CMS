"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, /**
 * For the provided image sizes, handle the resizing and the transforms
 * (format, trim, etc.) of each requested image size and return the result object.
 * This only handles the image sizes. The transforms of the original image
 * are handled in {@link ./generateFileData.ts}.
 *
 * The image will be resized according to the provided
 * resize config. If no image sizes are requested, the resolved data will be empty.
 * For every image that does not need to be resized, a result object with `null`
 * parameters will be returned.
 *
 * @param resizeConfig - the resize config
 * @returns the result of the resize operation(s)
 */ "default", {
    enumerable: true,
    get: function() {
        return resizeAndTransformImageSizes;
    }
});
const _filetype = require("file-type");
const _fs = /*#__PURE__*/ _interop_require_default(require("fs"));
const _sanitizefilename = /*#__PURE__*/ _interop_require_default(require("sanitize-filename"));
const _sharp = /*#__PURE__*/ _interop_require_default(require("sharp"));
const _isNumber = require("../utilities/isNumber");
const _fileExists = /*#__PURE__*/ _interop_require_default(require("./fileExists"));
function _interop_require_default(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}
/**
 * Sanitize the image name and extract the extension from the source image
 *
 * @param sourceImage - the source image
 * @returns the sanitized name and extension
 */ const getSanitizedImageData = (sourceImage)=>{
    const extension = sourceImage.split('.').pop();
    const name = (0, _sanitizefilename.default)(sourceImage.substring(0, sourceImage.lastIndexOf('.')) || sourceImage);
    return {
        name,
        ext: extension
    };
};
const createImageName = ({ extension, height, outputImageName, width })=>{
    return `${outputImageName}-${width}x${height}.${extension}`;
};
/**
 * Create the result object for the image resize operation based on the
 * provided parameters. If the name is not provided, an empty result object
 * is returned.
 *
 * @param name - the name of the image
 * @param filename - the filename of the image
 * @param width - the width of the image
 * @param height - the height of the image
 * @param filesize - the filesize of the image
 * @param mimeType - the mime type of the image
 * @param sizesToSave - the sizes to save
 * @returns the result object
 */ const createResult = ({ name, filename = null, filesize = null, height = null, mimeType = null, sizesToSave = [], width = null })=>{
    return {
        sizeData: {
            [name]: {
                filename,
                filesize,
                height,
                mimeType,
                width
            }
        },
        sizesToSave
    };
};
/**
 * Determine whether or not to resize the image.
 * - resize using image config
 * - resize using image config with focal adjustments
 * - do not resize at all
 *
 * `imageResizeConfig.withoutEnlargement`:
 * - undefined [default]: uploading images with smaller width AND height than the image size will return null
 * - false: always enlarge images to the image size
 * - true: if the image is smaller than the image size, return the original image
 *
 * `imageResizeConfig.withoutReduction`:
 * - false [default]: always enlarge images to the image size
 * - true: if the image is smaller than the image size, return the original image
 *
 * @return 'omit' | 'resize' | 'resizeWithFocalPoint'
 */ const getImageResizeAction = ({ dimensions: originalImage, hasFocalPoint, imageResizeConfig })=>{
    const { fit, height: targetHeight, width: targetWidth, withoutEnlargement, withoutReduction } = imageResizeConfig;
    // prevent upscaling by default when x and y are both smaller than target image size
    if (targetHeight && targetWidth) {
        const originalImageIsSmallerXAndY = originalImage.width < targetWidth && originalImage.height < targetHeight;
        if (withoutEnlargement === undefined && originalImageIsSmallerXAndY) {
            return 'omit' // prevent image size from being enlarged
            ;
        }
    }
    const originalImageIsSmallerXOrY = originalImage.width < targetWidth || originalImage.height < targetHeight;
    if (fit === 'contain' || fit === 'inside') return 'resize';
    if (!(0, _isNumber.isNumber)(targetHeight) && !(0, _isNumber.isNumber)(targetWidth)) return 'resize';
    const targetAspectRatio = targetWidth / targetHeight;
    const originalAspectRatio = originalImage.width / originalImage.height;
    if (originalAspectRatio === targetAspectRatio) return 'resize';
    if (withoutEnlargement && originalImageIsSmallerXOrY) return 'resize';
    if (withoutReduction && !originalImageIsSmallerXOrY) return 'resize';
    return hasFocalPoint ? 'resizeWithFocalPoint' : 'resize';
};
/**
 * Check if the image should be passed directly to sharp without payload adjusting properties.
 *
 * @param resizeConfig - object containing the requested dimensions and resize options
 * @param original - the original image size
 * @returns true if the image should passed directly to sharp
 */ const applyPayloadAdjustments = ({ fit, height, width, withoutEnlargement, withoutReduction }, original)=>{
    if (fit === 'contain' || fit === 'inside') return false;
    if (!(0, _isNumber.isNumber)(height) && !(0, _isNumber.isNumber)(width)) return false;
    const targetAspectRatio = width / height;
    const originalAspectRatio = original.width / original.height;
    if (originalAspectRatio === targetAspectRatio) return false;
    const skipEnlargement = withoutEnlargement && (original.height < height || original.width < width);
    const skipReduction = withoutReduction && (original.height > height || original.width > width);
    if (skipEnlargement || skipReduction) return false;
    return true;
};
/**
 * Sanitize the resize config. If the resize config has the `withoutReduction`
 * property set to true, the `fit` and `position` properties will be set to `contain`
 * and `top left` respectively.
 *
 * @param resizeConfig - the resize config
 * @returns a sanitized resize config
 */ const sanitizeResizeConfig = (resizeConfig)=>{
    if (resizeConfig.withoutReduction) {
        return {
            ...resizeConfig,
            // Why fit `contain` should also be set to https://github.com/lovell/sharp/issues/3595
            fit: resizeConfig?.fit || 'contain',
            position: resizeConfig?.position || 'left top'
        };
    }
    return resizeConfig;
};
/**
 * Used to extract height from images, animated or not.
 *
 * @param sharpMetadata - the sharp metadata
 * @returns the height of the image
 */ function extractHeightFromImage(sharpMetadata) {
    if (sharpMetadata?.pages) {
        return sharpMetadata.height / sharpMetadata.pages;
    }
    return sharpMetadata.height;
}
async function resizeAndTransformImageSizes({ config, dimensions, file, mimeType, req, savedFilename, staticPath, uploadEdits }) {
    const { focalPoint: focalPointEnabled = true, imageSizes } = config.upload;
    // Focal point adjustments
    const incomingFocalPoint = uploadEdits?.focalPoint ? {
        x: (0, _isNumber.isNumber)(uploadEdits.focalPoint.x) ? Math.round(uploadEdits.focalPoint.x) : 50,
        y: (0, _isNumber.isNumber)(uploadEdits.focalPoint.y) ? Math.round(uploadEdits.focalPoint.y) : 50
    } : undefined;
    const defaultResult = {
        ...focalPointEnabled && incomingFocalPoint && {
            focalPoint: incomingFocalPoint
        },
        sizeData: {},
        sizesToSave: []
    };
    // Nothing to resize here so return as early as possible
    if (!imageSizes) return defaultResult;
    // Determine if the file is animated
    const fileIsAnimatedType = [
        'image/avif',
        'image/gif',
        'image/webp'
    ].includes(file.mimetype);
    const sharpOptions = {};
    if (fileIsAnimatedType) sharpOptions.animated = true;
    const sharpBase = (0, _sharp.default)(file.tempFilePath || file.data, sharpOptions).rotate() // pass rotate() to auto-rotate based on EXIF data. https://github.com/payloadcms/payload/pull/3081
    ;
    const originalImageMeta = await sharpBase.metadata();
    const resizeImageMeta = {
        height: extractHeightFromImage(originalImageMeta),
        width: originalImageMeta.width
    };
    const results = await Promise.all(imageSizes.map(async (imageResizeConfig)=>{
        imageResizeConfig = sanitizeResizeConfig(imageResizeConfig);
        const resizeAction = getImageResizeAction({
            dimensions,
            hasFocalPoint: Boolean(incomingFocalPoint),
            imageResizeConfig
        });
        if (resizeAction === 'omit') return createResult({
            name: imageResizeConfig.name
        });
        const imageToResize = sharpBase.clone();
        let resized = imageToResize;
        if (resizeAction === 'resizeWithFocalPoint') {
            let { height: resizeHeight, width: resizeWidth } = imageResizeConfig;
            const originalAspectRatio = dimensions.width / dimensions.height;
            // Calculate resizeWidth based on original aspect ratio if it's undefined
            if (resizeHeight && !resizeWidth) {
                resizeWidth = Math.round(resizeHeight * originalAspectRatio);
            }
            // Calculate resizeHeight based on original aspect ratio if it's undefined
            if (resizeWidth && !resizeHeight) {
                resizeHeight = Math.round(resizeWidth / originalAspectRatio);
            }
            if (!resizeHeight) resizeHeight = resizeImageMeta.height;
            if (!resizeWidth) resizeWidth = resizeImageMeta.width;
            const resizeAspectRatio = resizeWidth / resizeHeight;
            const prioritizeHeight = resizeAspectRatio < originalAspectRatio;
            // Scales the image before extracting from it
            resized = imageToResize.resize({
                height: prioritizeHeight ? resizeHeight : undefined,
                width: prioritizeHeight ? undefined : resizeWidth
            });
            // must read from buffer, resize.metadata will return the original image metadata
            const { info } = await resized.toBuffer({
                resolveWithObject: true
            });
            resizeImageMeta.height = extractHeightFromImage({
                ...originalImageMeta,
                height: info.height
            });
            resizeImageMeta.width = info.width;
            const halfResizeX = resizeWidth / 2;
            const xFocalCenter = resizeImageMeta.width * (incomingFocalPoint.x / 100);
            const calculatedRightPixelBound = xFocalCenter + halfResizeX;
            let leftBound = xFocalCenter - halfResizeX;
            // if the right bound is greater than the image width, adjust the left bound
            // keeping focus on the right
            if (calculatedRightPixelBound > resizeImageMeta.width) {
                leftBound = resizeImageMeta.width - resizeWidth;
            }
            // if the left bound is less than 0, adjust the left bound to 0
            // keeping the focus on the left
            if (leftBound < 0) leftBound = 0;
            const halfResizeY = resizeHeight / 2;
            const yFocalCenter = resizeImageMeta.height * (incomingFocalPoint.y / 100);
            const calculatedBottomPixelBound = yFocalCenter + halfResizeY;
            let topBound = yFocalCenter - halfResizeY;
            // if the bottom bound is greater than the image height, adjust the top bound
            // keeping the image as far right as possible
            if (calculatedBottomPixelBound > resizeImageMeta.height) {
                topBound = resizeImageMeta.height - resizeHeight;
            }
            // if the top bound is less than 0, adjust the top bound to 0
            // keeping the image focus near the top
            if (topBound < 0) topBound = 0;
            resized = resized.extract({
                height: resizeHeight,
                left: Math.floor(leftBound),
                top: Math.floor(topBound),
                width: resizeWidth
            });
        } else {
            resized = imageToResize.resize(imageResizeConfig);
        }
        if (imageResizeConfig.formatOptions) {
            resized = resized.toFormat(imageResizeConfig.formatOptions.format, imageResizeConfig.formatOptions.options);
        }
        if (imageResizeConfig.trimOptions) {
            resized = resized.trim(imageResizeConfig.trimOptions);
        }
        const { data: bufferData, info: bufferInfo } = await resized.toBuffer({
            resolveWithObject: true
        });
        const sanitizedImage = getSanitizedImageData(savedFilename);
        if (req.payloadUploadSizes) {
            req.payloadUploadSizes[imageResizeConfig.name] = bufferData;
        }
        const mimeInfo = await (0, _filetype.fromBuffer)(bufferData);
        const imageNameWithDimensions = createImageName({
            extension: mimeInfo?.ext || sanitizedImage.ext,
            height: extractHeightFromImage({
                ...originalImageMeta,
                height: bufferInfo.height
            }),
            outputImageName: sanitizedImage.name,
            width: bufferInfo.width
        });
        const imagePath = `${staticPath}/${imageNameWithDimensions}`;
        if (await (0, _fileExists.default)(imagePath)) {
            try {
                _fs.default.unlinkSync(imagePath);
            } catch  {
            // Ignore unlink errors
            }
        }
        const { height, size, width } = bufferInfo;
        return createResult({
            name: imageResizeConfig.name,
            filename: imageNameWithDimensions,
            filesize: size,
            height: fileIsAnimatedType && originalImageMeta.pages ? height / originalImageMeta.pages : height,
            mimeType: mimeInfo?.mime || mimeType,
            sizesToSave: [
                {
                    buffer: bufferData,
                    path: imagePath
                }
            ],
            width
        });
    }));
    return results.reduce((acc, result)=>{
        Object.assign(acc.sizeData, result.sizeData);
        acc.sizesToSave.push(...result.sizesToSave);
        return acc;
    }, {
        ...defaultResult
    });
}

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy91cGxvYWRzL2ltYWdlUmVzaXplci50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgdHlwZSB7IFVwbG9hZGVkRmlsZSB9IGZyb20gJ2V4cHJlc3MtZmlsZXVwbG9hZCdcbmltcG9ydCB0eXBlIHsgU2hhcnAsIE1ldGFkYXRhIGFzIFNoYXJwTWV0YWRhdGEsIFNoYXJwT3B0aW9ucyB9IGZyb20gJ3NoYXJwJ1xuXG5pbXBvcnQgeyBmcm9tQnVmZmVyIH0gZnJvbSAnZmlsZS10eXBlJ1xuaW1wb3J0IGZzIGZyb20gJ2ZzJ1xuaW1wb3J0IHNhbml0aXplIGZyb20gJ3Nhbml0aXplLWZpbGVuYW1lJ1xuaW1wb3J0IHNoYXJwIGZyb20gJ3NoYXJwJ1xuXG5pbXBvcnQgdHlwZSB7IFNhbml0aXplZENvbGxlY3Rpb25Db25maWcgfSBmcm9tICcuLi9jb2xsZWN0aW9ucy9jb25maWcvdHlwZXMnXG5pbXBvcnQgdHlwZSB7IFBheWxvYWRSZXF1ZXN0IH0gZnJvbSAnLi4vZXhwcmVzcy90eXBlcydcbmltcG9ydCB0eXBlIHtcbiAgRmlsZVNpemUsXG4gIEZpbGVTaXplcyxcbiAgRmlsZVRvU2F2ZSxcbiAgSW1hZ2VTaXplLFxuICBQcm9iZWRJbWFnZVNpemUsXG4gIFVwbG9hZEVkaXRzLFxufSBmcm9tICcuL3R5cGVzJ1xuXG5pbXBvcnQgeyBpc051bWJlciB9IGZyb20gJy4uL3V0aWxpdGllcy9pc051bWJlcidcbmltcG9ydCBmaWxlRXhpc3RzIGZyb20gJy4vZmlsZUV4aXN0cydcblxudHlwZSBSZXNpemVBcmdzID0ge1xuICBjb25maWc6IFNhbml0aXplZENvbGxlY3Rpb25Db25maWdcbiAgZGltZW5zaW9uczogUHJvYmVkSW1hZ2VTaXplXG4gIGZpbGU6IFVwbG9hZGVkRmlsZVxuICBtaW1lVHlwZTogc3RyaW5nXG4gIHJlcTogUGF5bG9hZFJlcXVlc3RcbiAgc2F2ZWRGaWxlbmFtZTogc3RyaW5nXG4gIHN0YXRpY1BhdGg6IHN0cmluZ1xuICB1cGxvYWRFZGl0cz86IFVwbG9hZEVkaXRzXG59XG5cbi8qKiBSZXN1bHQgZnJvbSByZXNpemluZyBhbmQgdHJhbnNmb3JtaW5nIHRoZSByZXF1ZXN0ZWQgaW1hZ2Ugc2l6ZXMgKi9cbnR5cGUgSW1hZ2VTaXplc1Jlc3VsdCA9IHtcbiAgZm9jYWxQb2ludD86IFVwbG9hZEVkaXRzWydmb2NhbFBvaW50J11cbiAgc2l6ZURhdGE6IEZpbGVTaXplc1xuICBzaXplc1RvU2F2ZTogRmlsZVRvU2F2ZVtdXG59XG5cbnR5cGUgU2FuaXRpemVkSW1hZ2VEYXRhID0ge1xuICBleHQ6IHN0cmluZ1xuICBuYW1lOiBzdHJpbmdcbn1cblxuLyoqXG4gKiBTYW5pdGl6ZSB0aGUgaW1hZ2UgbmFtZSBhbmQgZXh0cmFjdCB0aGUgZXh0ZW5zaW9uIGZyb20gdGhlIHNvdXJjZSBpbWFnZVxuICpcbiAqIEBwYXJhbSBzb3VyY2VJbWFnZSAtIHRoZSBzb3VyY2UgaW1hZ2VcbiAqIEByZXR1cm5zIHRoZSBzYW5pdGl6ZWQgbmFtZSBhbmQgZXh0ZW5zaW9uXG4gKi9cbmNvbnN0IGdldFNhbml0aXplZEltYWdlRGF0YSA9IChzb3VyY2VJbWFnZTogc3RyaW5nKTogU2FuaXRpemVkSW1hZ2VEYXRhID0+IHtcbiAgY29uc3QgZXh0ZW5zaW9uID0gc291cmNlSW1hZ2Uuc3BsaXQoJy4nKS5wb3AoKVxuICBjb25zdCBuYW1lID0gc2FuaXRpemUoc291cmNlSW1hZ2Uuc3Vic3RyaW5nKDAsIHNvdXJjZUltYWdlLmxhc3RJbmRleE9mKCcuJykpIHx8IHNvdXJjZUltYWdlKVxuICByZXR1cm4geyBuYW1lLCBleHQ6IGV4dGVuc2lvbiB9XG59XG5cbi8qKlxuICogQ3JlYXRlIGEgbmV3IGltYWdlIG5hbWUgYmFzZWQgb24gdGhlIG91dHB1dCBpbWFnZSBuYW1lLCB0aGUgZGltZW5zaW9ucyBhbmRcbiAqIHRoZSBleHRlbnNpb24uXG4gKlxuICogSWdub3JlIHRoZSBmYWN0IHRoYXQgZHVwbGljYXRlIG5hbWVzIGNvdWxkIGhhcHBlbiBpZiB0aGUgdGhlcmUgaXMgb25lXG4gKiBzaXplIHdpdGggYHdpZHRoIEFORCBoZWlnaHRgIGFuZCBvbmUgd2l0aCBvbmx5IGBoZWlnaHQgT1Igd2lkdGhgLiBCZWNhdXNlXG4gKiBzcGFjZSBpcyBleHBlbnNpdmUsIHdlIHdpbGwgcmV1c2UgdGhlIHNhbWUgaW1hZ2UgZm9yIGJvdGggc2l6ZXMuXG4gKlxuICogQHBhcmFtIG91dHB1dEltYWdlTmFtZSAtIHRoZSBzYW5pdGl6ZWQgaW1hZ2UgbmFtZVxuICogQHBhcmFtIGJ1ZmZlckluZm8gLSB0aGUgYnVmZmVyIGluZm9cbiAqIEBwYXJhbSBleHRlbnNpb24gLSB0aGUgZXh0ZW5zaW9uIHRvIHVzZVxuICogQHJldHVybnMgdGhlIG5ldyBpbWFnZSBuYW1lIHRoYXQgaXMgbm90IHRha2VuXG4gKi9cblxudHlwZSBDcmVhdGVJbWFnZU5hbWVBcmdzID0ge1xuICBleHRlbnNpb246IHN0cmluZ1xuICBoZWlnaHQ6IG51bWJlclxuICBvdXRwdXRJbWFnZU5hbWU6IHN0cmluZ1xuICB3aWR0aDogbnVtYmVyXG59XG5jb25zdCBjcmVhdGVJbWFnZU5hbWUgPSAoe1xuICBleHRlbnNpb24sXG4gIGhlaWdodCxcbiAgb3V0cHV0SW1hZ2VOYW1lLFxuICB3aWR0aCxcbn06IENyZWF0ZUltYWdlTmFtZUFyZ3MpOiBzdHJpbmcgPT4ge1xuICByZXR1cm4gYCR7b3V0cHV0SW1hZ2VOYW1lfS0ke3dpZHRofXgke2hlaWdodH0uJHtleHRlbnNpb259YFxufVxuXG50eXBlIENyZWF0ZVJlc3VsdEFyZ3MgPSB7XG4gIGZpbGVuYW1lPzogRmlsZVNpemVbJ2ZpbGVuYW1lJ11cbiAgZmlsZXNpemU/OiBGaWxlU2l6ZVsnZmlsZXNpemUnXVxuICBoZWlnaHQ/OiBGaWxlU2l6ZVsnaGVpZ2h0J11cbiAgbWltZVR5cGU/OiBGaWxlU2l6ZVsnbWltZVR5cGUnXVxuICBuYW1lOiBzdHJpbmdcbiAgc2l6ZXNUb1NhdmU/OiBGaWxlVG9TYXZlW11cbiAgd2lkdGg/OiBGaWxlU2l6ZVsnd2lkdGgnXVxufVxuXG4vKipcbiAqIENyZWF0ZSB0aGUgcmVzdWx0IG9iamVjdCBmb3IgdGhlIGltYWdlIHJlc2l6ZSBvcGVyYXRpb24gYmFzZWQgb24gdGhlXG4gKiBwcm92aWRlZCBwYXJhbWV0ZXJzLiBJZiB0aGUgbmFtZSBpcyBub3QgcHJvdmlkZWQsIGFuIGVtcHR5IHJlc3VsdCBvYmplY3RcbiAqIGlzIHJldHVybmVkLlxuICpcbiAqIEBwYXJhbSBuYW1lIC0gdGhlIG5hbWUgb2YgdGhlIGltYWdlXG4gKiBAcGFyYW0gZmlsZW5hbWUgLSB0aGUgZmlsZW5hbWUgb2YgdGhlIGltYWdlXG4gKiBAcGFyYW0gd2lkdGggLSB0aGUgd2lkdGggb2YgdGhlIGltYWdlXG4gKiBAcGFyYW0gaGVpZ2h0IC0gdGhlIGhlaWdodCBvZiB0aGUgaW1hZ2VcbiAqIEBwYXJhbSBmaWxlc2l6ZSAtIHRoZSBmaWxlc2l6ZSBvZiB0aGUgaW1hZ2VcbiAqIEBwYXJhbSBtaW1lVHlwZSAtIHRoZSBtaW1lIHR5cGUgb2YgdGhlIGltYWdlXG4gKiBAcGFyYW0gc2l6ZXNUb1NhdmUgLSB0aGUgc2l6ZXMgdG8gc2F2ZVxuICogQHJldHVybnMgdGhlIHJlc3VsdCBvYmplY3RcbiAqL1xuY29uc3QgY3JlYXRlUmVzdWx0ID0gKHtcbiAgbmFtZSxcbiAgZmlsZW5hbWUgPSBudWxsLFxuICBmaWxlc2l6ZSA9IG51bGwsXG4gIGhlaWdodCA9IG51bGwsXG4gIG1pbWVUeXBlID0gbnVsbCxcbiAgc2l6ZXNUb1NhdmUgPSBbXSxcbiAgd2lkdGggPSBudWxsLFxufTogQ3JlYXRlUmVzdWx0QXJncyk6IEltYWdlU2l6ZXNSZXN1bHQgPT4ge1xuICByZXR1cm4ge1xuICAgIHNpemVEYXRhOiB7XG4gICAgICBbbmFtZV06IHtcbiAgICAgICAgZmlsZW5hbWUsXG4gICAgICAgIGZpbGVzaXplLFxuICAgICAgICBoZWlnaHQsXG4gICAgICAgIG1pbWVUeXBlLFxuICAgICAgICB3aWR0aCxcbiAgICAgIH0sXG4gICAgfSxcbiAgICBzaXplc1RvU2F2ZSxcbiAgfVxufVxuXG4vKipcbiAqIERldGVybWluZSB3aGV0aGVyIG9yIG5vdCB0byByZXNpemUgdGhlIGltYWdlLlxuICogLSByZXNpemUgdXNpbmcgaW1hZ2UgY29uZmlnXG4gKiAtIHJlc2l6ZSB1c2luZyBpbWFnZSBjb25maWcgd2l0aCBmb2NhbCBhZGp1c3RtZW50c1xuICogLSBkbyBub3QgcmVzaXplIGF0IGFsbFxuICpcbiAqIGBpbWFnZVJlc2l6ZUNvbmZpZy53aXRob3V0RW5sYXJnZW1lbnRgOlxuICogLSB1bmRlZmluZWQgW2RlZmF1bHRdOiB1cGxvYWRpbmcgaW1hZ2VzIHdpdGggc21hbGxlciB3aWR0aCBBTkQgaGVpZ2h0IHRoYW4gdGhlIGltYWdlIHNpemUgd2lsbCByZXR1cm4gbnVsbFxuICogLSBmYWxzZTogYWx3YXlzIGVubGFyZ2UgaW1hZ2VzIHRvIHRoZSBpbWFnZSBzaXplXG4gKiAtIHRydWU6IGlmIHRoZSBpbWFnZSBpcyBzbWFsbGVyIHRoYW4gdGhlIGltYWdlIHNpemUsIHJldHVybiB0aGUgb3JpZ2luYWwgaW1hZ2VcbiAqXG4gKiBgaW1hZ2VSZXNpemVDb25maWcud2l0aG91dFJlZHVjdGlvbmA6XG4gKiAtIGZhbHNlIFtkZWZhdWx0XTogYWx3YXlzIGVubGFyZ2UgaW1hZ2VzIHRvIHRoZSBpbWFnZSBzaXplXG4gKiAtIHRydWU6IGlmIHRoZSBpbWFnZSBpcyBzbWFsbGVyIHRoYW4gdGhlIGltYWdlIHNpemUsIHJldHVybiB0aGUgb3JpZ2luYWwgaW1hZ2VcbiAqXG4gKiBAcmV0dXJuICdvbWl0JyB8ICdyZXNpemUnIHwgJ3Jlc2l6ZVdpdGhGb2NhbFBvaW50J1xuICovXG5jb25zdCBnZXRJbWFnZVJlc2l6ZUFjdGlvbiA9ICh7XG4gIGRpbWVuc2lvbnM6IG9yaWdpbmFsSW1hZ2UsXG4gIGhhc0ZvY2FsUG9pbnQsXG4gIGltYWdlUmVzaXplQ29uZmlnLFxufToge1xuICBkaW1lbnNpb25zOiBQcm9iZWRJbWFnZVNpemVcbiAgaGFzRm9jYWxQb2ludD86IGJvb2xlYW5cbiAgaW1hZ2VSZXNpemVDb25maWc6IEltYWdlU2l6ZVxufSk6ICdvbWl0JyB8ICdyZXNpemUnIHwgJ3Jlc2l6ZVdpdGhGb2NhbFBvaW50JyA9PiB7XG4gIGNvbnN0IHtcbiAgICBmaXQsXG4gICAgaGVpZ2h0OiB0YXJnZXRIZWlnaHQsXG4gICAgd2lkdGg6IHRhcmdldFdpZHRoLFxuICAgIHdpdGhvdXRFbmxhcmdlbWVudCxcbiAgICB3aXRob3V0UmVkdWN0aW9uLFxuICB9ID0gaW1hZ2VSZXNpemVDb25maWdcblxuICAvLyBwcmV2ZW50IHVwc2NhbGluZyBieSBkZWZhdWx0IHdoZW4geCBhbmQgeSBhcmUgYm90aCBzbWFsbGVyIHRoYW4gdGFyZ2V0IGltYWdlIHNpemVcbiAgaWYgKHRhcmdldEhlaWdodCAmJiB0YXJnZXRXaWR0aCkge1xuICAgIGNvbnN0IG9yaWdpbmFsSW1hZ2VJc1NtYWxsZXJYQW5kWSA9XG4gICAgICBvcmlnaW5hbEltYWdlLndpZHRoIDwgdGFyZ2V0V2lkdGggJiYgb3JpZ2luYWxJbWFnZS5oZWlnaHQgPCB0YXJnZXRIZWlnaHRcbiAgICBpZiAod2l0aG91dEVubGFyZ2VtZW50ID09PSB1bmRlZmluZWQgJiYgb3JpZ2luYWxJbWFnZUlzU21hbGxlclhBbmRZKSB7XG4gICAgICByZXR1cm4gJ29taXQnIC8vIHByZXZlbnQgaW1hZ2Ugc2l6ZSBmcm9tIGJlaW5nIGVubGFyZ2VkXG4gICAgfVxuICB9XG5cbiAgY29uc3Qgb3JpZ2luYWxJbWFnZUlzU21hbGxlclhPclkgPVxuICAgIG9yaWdpbmFsSW1hZ2Uud2lkdGggPCB0YXJnZXRXaWR0aCB8fCBvcmlnaW5hbEltYWdlLmhlaWdodCA8IHRhcmdldEhlaWdodFxuICBpZiAoZml0ID09PSAnY29udGFpbicgfHwgZml0ID09PSAnaW5zaWRlJykgcmV0dXJuICdyZXNpemUnXG4gIGlmICghaXNOdW1iZXIodGFyZ2V0SGVpZ2h0KSAmJiAhaXNOdW1iZXIodGFyZ2V0V2lkdGgpKSByZXR1cm4gJ3Jlc2l6ZSdcblxuICBjb25zdCB0YXJnZXRBc3BlY3RSYXRpbyA9IHRhcmdldFdpZHRoIC8gdGFyZ2V0SGVpZ2h0XG4gIGNvbnN0IG9yaWdpbmFsQXNwZWN0UmF0aW8gPSBvcmlnaW5hbEltYWdlLndpZHRoIC8gb3JpZ2luYWxJbWFnZS5oZWlnaHRcbiAgaWYgKG9yaWdpbmFsQXNwZWN0UmF0aW8gPT09IHRhcmdldEFzcGVjdFJhdGlvKSByZXR1cm4gJ3Jlc2l6ZSdcblxuICBpZiAod2l0aG91dEVubGFyZ2VtZW50ICYmIG9yaWdpbmFsSW1hZ2VJc1NtYWxsZXJYT3JZKSByZXR1cm4gJ3Jlc2l6ZSdcbiAgaWYgKHdpdGhvdXRSZWR1Y3Rpb24gJiYgIW9yaWdpbmFsSW1hZ2VJc1NtYWxsZXJYT3JZKSByZXR1cm4gJ3Jlc2l6ZSdcblxuICByZXR1cm4gaGFzRm9jYWxQb2ludCA/ICdyZXNpemVXaXRoRm9jYWxQb2ludCcgOiAncmVzaXplJ1xufVxuXG4vKipcbiAqIENoZWNrIGlmIHRoZSBpbWFnZSBzaG91bGQgYmUgcGFzc2VkIGRpcmVjdGx5IHRvIHNoYXJwIHdpdGhvdXQgcGF5bG9hZCBhZGp1c3RpbmcgcHJvcGVydGllcy5cbiAqXG4gKiBAcGFyYW0gcmVzaXplQ29uZmlnIC0gb2JqZWN0IGNvbnRhaW5pbmcgdGhlIHJlcXVlc3RlZCBkaW1lbnNpb25zIGFuZCByZXNpemUgb3B0aW9uc1xuICogQHBhcmFtIG9yaWdpbmFsIC0gdGhlIG9yaWdpbmFsIGltYWdlIHNpemVcbiAqIEByZXR1cm5zIHRydWUgaWYgdGhlIGltYWdlIHNob3VsZCBwYXNzZWQgZGlyZWN0bHkgdG8gc2hhcnBcbiAqL1xuY29uc3QgYXBwbHlQYXlsb2FkQWRqdXN0bWVudHMgPSAoXG4gIHsgZml0LCBoZWlnaHQsIHdpZHRoLCB3aXRob3V0RW5sYXJnZW1lbnQsIHdpdGhvdXRSZWR1Y3Rpb24gfTogSW1hZ2VTaXplLFxuICBvcmlnaW5hbDogUHJvYmVkSW1hZ2VTaXplLFxuKSA9PiB7XG4gIGlmIChmaXQgPT09ICdjb250YWluJyB8fCBmaXQgPT09ICdpbnNpZGUnKSByZXR1cm4gZmFsc2VcbiAgaWYgKCFpc051bWJlcihoZWlnaHQpICYmICFpc051bWJlcih3aWR0aCkpIHJldHVybiBmYWxzZVxuXG4gIGNvbnN0IHRhcmdldEFzcGVjdFJhdGlvID0gd2lkdGggLyBoZWlnaHRcbiAgY29uc3Qgb3JpZ2luYWxBc3BlY3RSYXRpbyA9IG9yaWdpbmFsLndpZHRoIC8gb3JpZ2luYWwuaGVpZ2h0XG4gIGlmIChvcmlnaW5hbEFzcGVjdFJhdGlvID09PSB0YXJnZXRBc3BlY3RSYXRpbykgcmV0dXJuIGZhbHNlXG5cbiAgY29uc3Qgc2tpcEVubGFyZ2VtZW50ID0gd2l0aG91dEVubGFyZ2VtZW50ICYmIChvcmlnaW5hbC5oZWlnaHQgPCBoZWlnaHQgfHwgb3JpZ2luYWwud2lkdGggPCB3aWR0aClcbiAgY29uc3Qgc2tpcFJlZHVjdGlvbiA9IHdpdGhvdXRSZWR1Y3Rpb24gJiYgKG9yaWdpbmFsLmhlaWdodCA+IGhlaWdodCB8fCBvcmlnaW5hbC53aWR0aCA+IHdpZHRoKVxuICBpZiAoc2tpcEVubGFyZ2VtZW50IHx8IHNraXBSZWR1Y3Rpb24pIHJldHVybiBmYWxzZVxuXG4gIHJldHVybiB0cnVlXG59XG5cbi8qKlxuICogU2FuaXRpemUgdGhlIHJlc2l6ZSBjb25maWcuIElmIHRoZSByZXNpemUgY29uZmlnIGhhcyB0aGUgYHdpdGhvdXRSZWR1Y3Rpb25gXG4gKiBwcm9wZXJ0eSBzZXQgdG8gdHJ1ZSwgdGhlIGBmaXRgIGFuZCBgcG9zaXRpb25gIHByb3BlcnRpZXMgd2lsbCBiZSBzZXQgdG8gYGNvbnRhaW5gXG4gKiBhbmQgYHRvcCBsZWZ0YCByZXNwZWN0aXZlbHkuXG4gKlxuICogQHBhcmFtIHJlc2l6ZUNvbmZpZyAtIHRoZSByZXNpemUgY29uZmlnXG4gKiBAcmV0dXJucyBhIHNhbml0aXplZCByZXNpemUgY29uZmlnXG4gKi9cbmNvbnN0IHNhbml0aXplUmVzaXplQ29uZmlnID0gKHJlc2l6ZUNvbmZpZzogSW1hZ2VTaXplKTogSW1hZ2VTaXplID0+IHtcbiAgaWYgKHJlc2l6ZUNvbmZpZy53aXRob3V0UmVkdWN0aW9uKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLnJlc2l6ZUNvbmZpZyxcbiAgICAgIC8vIFdoeSBmaXQgYGNvbnRhaW5gIHNob3VsZCBhbHNvIGJlIHNldCB0byBodHRwczovL2dpdGh1Yi5jb20vbG92ZWxsL3NoYXJwL2lzc3Vlcy8zNTk1XG4gICAgICBmaXQ6IHJlc2l6ZUNvbmZpZz8uZml0IHx8ICdjb250YWluJyxcbiAgICAgIHBvc2l0aW9uOiByZXNpemVDb25maWc/LnBvc2l0aW9uIHx8ICdsZWZ0IHRvcCcsXG4gICAgfVxuICB9XG4gIHJldHVybiByZXNpemVDb25maWdcbn1cblxuLyoqXG4gKiBVc2VkIHRvIGV4dHJhY3QgaGVpZ2h0IGZyb20gaW1hZ2VzLCBhbmltYXRlZCBvciBub3QuXG4gKlxuICogQHBhcmFtIHNoYXJwTWV0YWRhdGEgLSB0aGUgc2hhcnAgbWV0YWRhdGFcbiAqIEByZXR1cm5zIHRoZSBoZWlnaHQgb2YgdGhlIGltYWdlXG4gKi9cbmZ1bmN0aW9uIGV4dHJhY3RIZWlnaHRGcm9tSW1hZ2Uoc2hhcnBNZXRhZGF0YTogU2hhcnBNZXRhZGF0YSk6IG51bWJlciB7XG4gIGlmIChzaGFycE1ldGFkYXRhPy5wYWdlcykge1xuICAgIHJldHVybiBzaGFycE1ldGFkYXRhLmhlaWdodCAvIHNoYXJwTWV0YWRhdGEucGFnZXNcbiAgfVxuICByZXR1cm4gc2hhcnBNZXRhZGF0YS5oZWlnaHRcbn1cblxuLyoqXG4gKiBGb3IgdGhlIHByb3ZpZGVkIGltYWdlIHNpemVzLCBoYW5kbGUgdGhlIHJlc2l6aW5nIGFuZCB0aGUgdHJhbnNmb3Jtc1xuICogKGZvcm1hdCwgdHJpbSwgZXRjLikgb2YgZWFjaCByZXF1ZXN0ZWQgaW1hZ2Ugc2l6ZSBhbmQgcmV0dXJuIHRoZSByZXN1bHQgb2JqZWN0LlxuICogVGhpcyBvbmx5IGhhbmRsZXMgdGhlIGltYWdlIHNpemVzLiBUaGUgdHJhbnNmb3JtcyBvZiB0aGUgb3JpZ2luYWwgaW1hZ2VcbiAqIGFyZSBoYW5kbGVkIGluIHtAbGluayAuL2dlbmVyYXRlRmlsZURhdGEudHN9LlxuICpcbiAqIFRoZSBpbWFnZSB3aWxsIGJlIHJlc2l6ZWQgYWNjb3JkaW5nIHRvIHRoZSBwcm92aWRlZFxuICogcmVzaXplIGNvbmZpZy4gSWYgbm8gaW1hZ2Ugc2l6ZXMgYXJlIHJlcXVlc3RlZCwgdGhlIHJlc29sdmVkIGRhdGEgd2lsbCBiZSBlbXB0eS5cbiAqIEZvciBldmVyeSBpbWFnZSB0aGF0IGRvZXMgbm90IG5lZWQgdG8gYmUgcmVzaXplZCwgYSByZXN1bHQgb2JqZWN0IHdpdGggYG51bGxgXG4gKiBwYXJhbWV0ZXJzIHdpbGwgYmUgcmV0dXJuZWQuXG4gKlxuICogQHBhcmFtIHJlc2l6ZUNvbmZpZyAtIHRoZSByZXNpemUgY29uZmlnXG4gKiBAcmV0dXJucyB0aGUgcmVzdWx0IG9mIHRoZSByZXNpemUgb3BlcmF0aW9uKHMpXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGFzeW5jIGZ1bmN0aW9uIHJlc2l6ZUFuZFRyYW5zZm9ybUltYWdlU2l6ZXMoe1xuICBjb25maWcsXG4gIGRpbWVuc2lvbnMsXG4gIGZpbGUsXG4gIG1pbWVUeXBlLFxuICByZXEsXG4gIHNhdmVkRmlsZW5hbWUsXG4gIHN0YXRpY1BhdGgsXG4gIHVwbG9hZEVkaXRzLFxufTogUmVzaXplQXJncyk6IFByb21pc2U8SW1hZ2VTaXplc1Jlc3VsdD4ge1xuICBjb25zdCB7IGZvY2FsUG9pbnQ6IGZvY2FsUG9pbnRFbmFibGVkID0gdHJ1ZSwgaW1hZ2VTaXplcyB9ID0gY29uZmlnLnVwbG9hZFxuXG4gIC8vIEZvY2FsIHBvaW50IGFkanVzdG1lbnRzXG4gIGNvbnN0IGluY29taW5nRm9jYWxQb2ludCA9IHVwbG9hZEVkaXRzPy5mb2NhbFBvaW50XG4gICAgPyB7XG4gICAgICAgIHg6IGlzTnVtYmVyKHVwbG9hZEVkaXRzLmZvY2FsUG9pbnQueCkgPyBNYXRoLnJvdW5kKHVwbG9hZEVkaXRzLmZvY2FsUG9pbnQueCkgOiA1MCxcbiAgICAgICAgeTogaXNOdW1iZXIodXBsb2FkRWRpdHMuZm9jYWxQb2ludC55KSA/IE1hdGgucm91bmQodXBsb2FkRWRpdHMuZm9jYWxQb2ludC55KSA6IDUwLFxuICAgICAgfVxuICAgIDogdW5kZWZpbmVkXG5cbiAgY29uc3QgZGVmYXVsdFJlc3VsdDogSW1hZ2VTaXplc1Jlc3VsdCA9IHtcbiAgICAuLi4oZm9jYWxQb2ludEVuYWJsZWQgJiYgaW5jb21pbmdGb2NhbFBvaW50ICYmIHsgZm9jYWxQb2ludDogaW5jb21pbmdGb2NhbFBvaW50IH0pLFxuICAgIHNpemVEYXRhOiB7fSxcbiAgICBzaXplc1RvU2F2ZTogW10sXG4gIH1cblxuICAvLyBOb3RoaW5nIHRvIHJlc2l6ZSBoZXJlIHNvIHJldHVybiBhcyBlYXJseSBhcyBwb3NzaWJsZVxuICBpZiAoIWltYWdlU2l6ZXMpIHJldHVybiBkZWZhdWx0UmVzdWx0XG5cbiAgLy8gRGV0ZXJtaW5lIGlmIHRoZSBmaWxlIGlzIGFuaW1hdGVkXG4gIGNvbnN0IGZpbGVJc0FuaW1hdGVkVHlwZSA9IFsnaW1hZ2UvYXZpZicsICdpbWFnZS9naWYnLCAnaW1hZ2Uvd2VicCddLmluY2x1ZGVzKGZpbGUubWltZXR5cGUpXG4gIGNvbnN0IHNoYXJwT3B0aW9uczogU2hhcnBPcHRpb25zID0ge31cblxuICBpZiAoZmlsZUlzQW5pbWF0ZWRUeXBlKSBzaGFycE9wdGlvbnMuYW5pbWF0ZWQgPSB0cnVlXG5cbiAgY29uc3Qgc2hhcnBCYXNlOiBTaGFycCB8IHVuZGVmaW5lZCA9IHNoYXJwKGZpbGUudGVtcEZpbGVQYXRoIHx8IGZpbGUuZGF0YSwgc2hhcnBPcHRpb25zKS5yb3RhdGUoKSAvLyBwYXNzIHJvdGF0ZSgpIHRvIGF1dG8tcm90YXRlIGJhc2VkIG9uIEVYSUYgZGF0YS4gaHR0cHM6Ly9naXRodWIuY29tL3BheWxvYWRjbXMvcGF5bG9hZC9wdWxsLzMwODFcbiAgY29uc3Qgb3JpZ2luYWxJbWFnZU1ldGEgPSBhd2FpdCBzaGFycEJhc2UubWV0YWRhdGEoKVxuXG4gIGNvbnN0IHJlc2l6ZUltYWdlTWV0YSA9IHtcbiAgICBoZWlnaHQ6IGV4dHJhY3RIZWlnaHRGcm9tSW1hZ2Uob3JpZ2luYWxJbWFnZU1ldGEpLFxuICAgIHdpZHRoOiBvcmlnaW5hbEltYWdlTWV0YS53aWR0aCxcbiAgfVxuXG4gIGNvbnN0IHJlc3VsdHM6IEltYWdlU2l6ZXNSZXN1bHRbXSA9IGF3YWl0IFByb21pc2UuYWxsKFxuICAgIGltYWdlU2l6ZXMubWFwKGFzeW5jIChpbWFnZVJlc2l6ZUNvbmZpZyk6IFByb21pc2U8SW1hZ2VTaXplc1Jlc3VsdD4gPT4ge1xuICAgICAgaW1hZ2VSZXNpemVDb25maWcgPSBzYW5pdGl6ZVJlc2l6ZUNvbmZpZyhpbWFnZVJlc2l6ZUNvbmZpZylcblxuICAgICAgY29uc3QgcmVzaXplQWN0aW9uID0gZ2V0SW1hZ2VSZXNpemVBY3Rpb24oe1xuICAgICAgICBkaW1lbnNpb25zLFxuICAgICAgICBoYXNGb2NhbFBvaW50OiBCb29sZWFuKGluY29taW5nRm9jYWxQb2ludCksXG4gICAgICAgIGltYWdlUmVzaXplQ29uZmlnLFxuICAgICAgfSlcbiAgICAgIGlmIChyZXNpemVBY3Rpb24gPT09ICdvbWl0JykgcmV0dXJuIGNyZWF0ZVJlc3VsdCh7IG5hbWU6IGltYWdlUmVzaXplQ29uZmlnLm5hbWUgfSlcblxuICAgICAgY29uc3QgaW1hZ2VUb1Jlc2l6ZSA9IHNoYXJwQmFzZS5jbG9uZSgpXG4gICAgICBsZXQgcmVzaXplZCA9IGltYWdlVG9SZXNpemVcblxuICAgICAgaWYgKHJlc2l6ZUFjdGlvbiA9PT0gJ3Jlc2l6ZVdpdGhGb2NhbFBvaW50Jykge1xuICAgICAgICBsZXQgeyBoZWlnaHQ6IHJlc2l6ZUhlaWdodCwgd2lkdGg6IHJlc2l6ZVdpZHRoIH0gPSBpbWFnZVJlc2l6ZUNvbmZpZ1xuXG4gICAgICAgIGNvbnN0IG9yaWdpbmFsQXNwZWN0UmF0aW8gPSBkaW1lbnNpb25zLndpZHRoIC8gZGltZW5zaW9ucy5oZWlnaHRcblxuICAgICAgICAvLyBDYWxjdWxhdGUgcmVzaXplV2lkdGggYmFzZWQgb24gb3JpZ2luYWwgYXNwZWN0IHJhdGlvIGlmIGl0J3MgdW5kZWZpbmVkXG4gICAgICAgIGlmIChyZXNpemVIZWlnaHQgJiYgIXJlc2l6ZVdpZHRoKSB7XG4gICAgICAgICAgcmVzaXplV2lkdGggPSBNYXRoLnJvdW5kKHJlc2l6ZUhlaWdodCAqIG9yaWdpbmFsQXNwZWN0UmF0aW8pXG4gICAgICAgIH1cblxuICAgICAgICAvLyBDYWxjdWxhdGUgcmVzaXplSGVpZ2h0IGJhc2VkIG9uIG9yaWdpbmFsIGFzcGVjdCByYXRpbyBpZiBpdCdzIHVuZGVmaW5lZFxuICAgICAgICBpZiAocmVzaXplV2lkdGggJiYgIXJlc2l6ZUhlaWdodCkge1xuICAgICAgICAgIHJlc2l6ZUhlaWdodCA9IE1hdGgucm91bmQocmVzaXplV2lkdGggLyBvcmlnaW5hbEFzcGVjdFJhdGlvKVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFyZXNpemVIZWlnaHQpIHJlc2l6ZUhlaWdodCA9IHJlc2l6ZUltYWdlTWV0YS5oZWlnaHRcbiAgICAgICAgaWYgKCFyZXNpemVXaWR0aCkgcmVzaXplV2lkdGggPSByZXNpemVJbWFnZU1ldGEud2lkdGhcblxuICAgICAgICBjb25zdCByZXNpemVBc3BlY3RSYXRpbyA9IHJlc2l6ZVdpZHRoIC8gcmVzaXplSGVpZ2h0XG4gICAgICAgIGNvbnN0IHByaW9yaXRpemVIZWlnaHQgPSByZXNpemVBc3BlY3RSYXRpbyA8IG9yaWdpbmFsQXNwZWN0UmF0aW9cbiAgICAgICAgLy8gU2NhbGVzIHRoZSBpbWFnZSBiZWZvcmUgZXh0cmFjdGluZyBmcm9tIGl0XG4gICAgICAgIHJlc2l6ZWQgPSBpbWFnZVRvUmVzaXplLnJlc2l6ZSh7XG4gICAgICAgICAgaGVpZ2h0OiBwcmlvcml0aXplSGVpZ2h0ID8gcmVzaXplSGVpZ2h0IDogdW5kZWZpbmVkLFxuICAgICAgICAgIHdpZHRoOiBwcmlvcml0aXplSGVpZ2h0ID8gdW5kZWZpbmVkIDogcmVzaXplV2lkdGgsXG4gICAgICAgIH0pXG5cbiAgICAgICAgLy8gbXVzdCByZWFkIGZyb20gYnVmZmVyLCByZXNpemUubWV0YWRhdGEgd2lsbCByZXR1cm4gdGhlIG9yaWdpbmFsIGltYWdlIG1ldGFkYXRhXG4gICAgICAgIGNvbnN0IHsgaW5mbyB9ID0gYXdhaXQgcmVzaXplZC50b0J1ZmZlcih7IHJlc29sdmVXaXRoT2JqZWN0OiB0cnVlIH0pXG4gICAgICAgIHJlc2l6ZUltYWdlTWV0YS5oZWlnaHQgPSBleHRyYWN0SGVpZ2h0RnJvbUltYWdlKHtcbiAgICAgICAgICAuLi5vcmlnaW5hbEltYWdlTWV0YSxcbiAgICAgICAgICBoZWlnaHQ6IGluZm8uaGVpZ2h0LFxuICAgICAgICB9KVxuICAgICAgICByZXNpemVJbWFnZU1ldGEud2lkdGggPSBpbmZvLndpZHRoXG5cbiAgICAgICAgY29uc3QgaGFsZlJlc2l6ZVggPSByZXNpemVXaWR0aCAvIDJcbiAgICAgICAgY29uc3QgeEZvY2FsQ2VudGVyID0gcmVzaXplSW1hZ2VNZXRhLndpZHRoICogKGluY29taW5nRm9jYWxQb2ludC54IC8gMTAwKVxuICAgICAgICBjb25zdCBjYWxjdWxhdGVkUmlnaHRQaXhlbEJvdW5kID0geEZvY2FsQ2VudGVyICsgaGFsZlJlc2l6ZVhcbiAgICAgICAgbGV0IGxlZnRCb3VuZCA9IHhGb2NhbENlbnRlciAtIGhhbGZSZXNpemVYXG5cbiAgICAgICAgLy8gaWYgdGhlIHJpZ2h0IGJvdW5kIGlzIGdyZWF0ZXIgdGhhbiB0aGUgaW1hZ2Ugd2lkdGgsIGFkanVzdCB0aGUgbGVmdCBib3VuZFxuICAgICAgICAvLyBrZWVwaW5nIGZvY3VzIG9uIHRoZSByaWdodFxuICAgICAgICBpZiAoY2FsY3VsYXRlZFJpZ2h0UGl4ZWxCb3VuZCA+IHJlc2l6ZUltYWdlTWV0YS53aWR0aCkge1xuICAgICAgICAgIGxlZnRCb3VuZCA9IHJlc2l6ZUltYWdlTWV0YS53aWR0aCAtIHJlc2l6ZVdpZHRoXG4gICAgICAgIH1cblxuICAgICAgICAvLyBpZiB0aGUgbGVmdCBib3VuZCBpcyBsZXNzIHRoYW4gMCwgYWRqdXN0IHRoZSBsZWZ0IGJvdW5kIHRvIDBcbiAgICAgICAgLy8ga2VlcGluZyB0aGUgZm9jdXMgb24gdGhlIGxlZnRcbiAgICAgICAgaWYgKGxlZnRCb3VuZCA8IDApIGxlZnRCb3VuZCA9IDBcblxuICAgICAgICBjb25zdCBoYWxmUmVzaXplWSA9IHJlc2l6ZUhlaWdodCAvIDJcbiAgICAgICAgY29uc3QgeUZvY2FsQ2VudGVyID0gcmVzaXplSW1hZ2VNZXRhLmhlaWdodCAqIChpbmNvbWluZ0ZvY2FsUG9pbnQueSAvIDEwMClcbiAgICAgICAgY29uc3QgY2FsY3VsYXRlZEJvdHRvbVBpeGVsQm91bmQgPSB5Rm9jYWxDZW50ZXIgKyBoYWxmUmVzaXplWVxuICAgICAgICBsZXQgdG9wQm91bmQgPSB5Rm9jYWxDZW50ZXIgLSBoYWxmUmVzaXplWVxuXG4gICAgICAgIC8vIGlmIHRoZSBib3R0b20gYm91bmQgaXMgZ3JlYXRlciB0aGFuIHRoZSBpbWFnZSBoZWlnaHQsIGFkanVzdCB0aGUgdG9wIGJvdW5kXG4gICAgICAgIC8vIGtlZXBpbmcgdGhlIGltYWdlIGFzIGZhciByaWdodCBhcyBwb3NzaWJsZVxuICAgICAgICBpZiAoY2FsY3VsYXRlZEJvdHRvbVBpeGVsQm91bmQgPiByZXNpemVJbWFnZU1ldGEuaGVpZ2h0KSB7XG4gICAgICAgICAgdG9wQm91bmQgPSByZXNpemVJbWFnZU1ldGEuaGVpZ2h0IC0gcmVzaXplSGVpZ2h0XG4gICAgICAgIH1cblxuICAgICAgICAvLyBpZiB0aGUgdG9wIGJvdW5kIGlzIGxlc3MgdGhhbiAwLCBhZGp1c3QgdGhlIHRvcCBib3VuZCB0byAwXG4gICAgICAgIC8vIGtlZXBpbmcgdGhlIGltYWdlIGZvY3VzIG5lYXIgdGhlIHRvcFxuICAgICAgICBpZiAodG9wQm91bmQgPCAwKSB0b3BCb3VuZCA9IDBcblxuICAgICAgICByZXNpemVkID0gcmVzaXplZC5leHRyYWN0KHtcbiAgICAgICAgICBoZWlnaHQ6IHJlc2l6ZUhlaWdodCxcbiAgICAgICAgICBsZWZ0OiBNYXRoLmZsb29yKGxlZnRCb3VuZCksXG4gICAgICAgICAgdG9wOiBNYXRoLmZsb29yKHRvcEJvdW5kKSxcbiAgICAgICAgICB3aWR0aDogcmVzaXplV2lkdGgsXG4gICAgICAgIH0pXG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXNpemVkID0gaW1hZ2VUb1Jlc2l6ZS5yZXNpemUoaW1hZ2VSZXNpemVDb25maWcpXG4gICAgICB9XG5cbiAgICAgIGlmIChpbWFnZVJlc2l6ZUNvbmZpZy5mb3JtYXRPcHRpb25zKSB7XG4gICAgICAgIHJlc2l6ZWQgPSByZXNpemVkLnRvRm9ybWF0KFxuICAgICAgICAgIGltYWdlUmVzaXplQ29uZmlnLmZvcm1hdE9wdGlvbnMuZm9ybWF0LFxuICAgICAgICAgIGltYWdlUmVzaXplQ29uZmlnLmZvcm1hdE9wdGlvbnMub3B0aW9ucyxcbiAgICAgICAgKVxuICAgICAgfVxuXG4gICAgICBpZiAoaW1hZ2VSZXNpemVDb25maWcudHJpbU9wdGlvbnMpIHtcbiAgICAgICAgcmVzaXplZCA9IHJlc2l6ZWQudHJpbShpbWFnZVJlc2l6ZUNvbmZpZy50cmltT3B0aW9ucylcbiAgICAgIH1cblxuICAgICAgY29uc3QgeyBkYXRhOiBidWZmZXJEYXRhLCBpbmZvOiBidWZmZXJJbmZvIH0gPSBhd2FpdCByZXNpemVkLnRvQnVmZmVyKHtcbiAgICAgICAgcmVzb2x2ZVdpdGhPYmplY3Q6IHRydWUsXG4gICAgICB9KVxuXG4gICAgICBjb25zdCBzYW5pdGl6ZWRJbWFnZSA9IGdldFNhbml0aXplZEltYWdlRGF0YShzYXZlZEZpbGVuYW1lKVxuXG4gICAgICBpZiAocmVxLnBheWxvYWRVcGxvYWRTaXplcykge1xuICAgICAgICByZXEucGF5bG9hZFVwbG9hZFNpemVzW2ltYWdlUmVzaXplQ29uZmlnLm5hbWVdID0gYnVmZmVyRGF0YVxuICAgICAgfVxuXG4gICAgICBjb25zdCBtaW1lSW5mbyA9IGF3YWl0IGZyb21CdWZmZXIoYnVmZmVyRGF0YSlcblxuICAgICAgY29uc3QgaW1hZ2VOYW1lV2l0aERpbWVuc2lvbnMgPSBjcmVhdGVJbWFnZU5hbWUoe1xuICAgICAgICBleHRlbnNpb246IG1pbWVJbmZvPy5leHQgfHwgc2FuaXRpemVkSW1hZ2UuZXh0LFxuICAgICAgICBoZWlnaHQ6IGV4dHJhY3RIZWlnaHRGcm9tSW1hZ2Uoe1xuICAgICAgICAgIC4uLm9yaWdpbmFsSW1hZ2VNZXRhLFxuICAgICAgICAgIGhlaWdodDogYnVmZmVySW5mby5oZWlnaHQsXG4gICAgICAgIH0pLFxuICAgICAgICBvdXRwdXRJbWFnZU5hbWU6IHNhbml0aXplZEltYWdlLm5hbWUsXG4gICAgICAgIHdpZHRoOiBidWZmZXJJbmZvLndpZHRoLFxuICAgICAgfSlcblxuICAgICAgY29uc3QgaW1hZ2VQYXRoID0gYCR7c3RhdGljUGF0aH0vJHtpbWFnZU5hbWVXaXRoRGltZW5zaW9uc31gXG5cbiAgICAgIGlmIChhd2FpdCBmaWxlRXhpc3RzKGltYWdlUGF0aCkpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBmcy51bmxpbmtTeW5jKGltYWdlUGF0aClcbiAgICAgICAgfSBjYXRjaCB7XG4gICAgICAgICAgLy8gSWdub3JlIHVubGluayBlcnJvcnNcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBjb25zdCB7IGhlaWdodCwgc2l6ZSwgd2lkdGggfSA9IGJ1ZmZlckluZm9cbiAgICAgIHJldHVybiBjcmVhdGVSZXN1bHQoe1xuICAgICAgICBuYW1lOiBpbWFnZVJlc2l6ZUNvbmZpZy5uYW1lLFxuICAgICAgICBmaWxlbmFtZTogaW1hZ2VOYW1lV2l0aERpbWVuc2lvbnMsXG4gICAgICAgIGZpbGVzaXplOiBzaXplLFxuICAgICAgICBoZWlnaHQ6XG4gICAgICAgICAgZmlsZUlzQW5pbWF0ZWRUeXBlICYmIG9yaWdpbmFsSW1hZ2VNZXRhLnBhZ2VzID8gaGVpZ2h0IC8gb3JpZ2luYWxJbWFnZU1ldGEucGFnZXMgOiBoZWlnaHQsXG4gICAgICAgIG1pbWVUeXBlOiBtaW1lSW5mbz8ubWltZSB8fCBtaW1lVHlwZSxcbiAgICAgICAgc2l6ZXNUb1NhdmU6IFt7IGJ1ZmZlcjogYnVmZmVyRGF0YSwgcGF0aDogaW1hZ2VQYXRoIH1dLFxuICAgICAgICB3aWR0aCxcbiAgICAgIH0pXG4gICAgfSksXG4gIClcblxuICByZXR1cm4gcmVzdWx0cy5yZWR1Y2UoXG4gICAgKGFjYywgcmVzdWx0KSA9PiB7XG4gICAgICBPYmplY3QuYXNzaWduKGFjYy5zaXplRGF0YSwgcmVzdWx0LnNpemVEYXRhKVxuICAgICAgYWNjLnNpemVzVG9TYXZlLnB1c2goLi4ucmVzdWx0LnNpemVzVG9TYXZlKVxuICAgICAgcmV0dXJuIGFjY1xuICAgIH0sXG4gICAgeyAuLi5kZWZhdWx0UmVzdWx0IH0sXG4gIClcbn1cbiJdLCJuYW1lcyI6WyJyZXNpemVBbmRUcmFuc2Zvcm1JbWFnZVNpemVzIiwiZ2V0U2FuaXRpemVkSW1hZ2VEYXRhIiwic291cmNlSW1hZ2UiLCJleHRlbnNpb24iLCJzcGxpdCIsInBvcCIsIm5hbWUiLCJzYW5pdGl6ZSIsInN1YnN0cmluZyIsImxhc3RJbmRleE9mIiwiZXh0IiwiY3JlYXRlSW1hZ2VOYW1lIiwiaGVpZ2h0Iiwib3V0cHV0SW1hZ2VOYW1lIiwid2lkdGgiLCJjcmVhdGVSZXN1bHQiLCJmaWxlbmFtZSIsImZpbGVzaXplIiwibWltZVR5cGUiLCJzaXplc1RvU2F2ZSIsInNpemVEYXRhIiwiZ2V0SW1hZ2VSZXNpemVBY3Rpb24iLCJkaW1lbnNpb25zIiwib3JpZ2luYWxJbWFnZSIsImhhc0ZvY2FsUG9pbnQiLCJpbWFnZVJlc2l6ZUNvbmZpZyIsImZpdCIsInRhcmdldEhlaWdodCIsInRhcmdldFdpZHRoIiwid2l0aG91dEVubGFyZ2VtZW50Iiwid2l0aG91dFJlZHVjdGlvbiIsIm9yaWdpbmFsSW1hZ2VJc1NtYWxsZXJYQW5kWSIsInVuZGVmaW5lZCIsIm9yaWdpbmFsSW1hZ2VJc1NtYWxsZXJYT3JZIiwiaXNOdW1iZXIiLCJ0YXJnZXRBc3BlY3RSYXRpbyIsIm9yaWdpbmFsQXNwZWN0UmF0aW8iLCJhcHBseVBheWxvYWRBZGp1c3RtZW50cyIsIm9yaWdpbmFsIiwic2tpcEVubGFyZ2VtZW50Iiwic2tpcFJlZHVjdGlvbiIsInNhbml0aXplUmVzaXplQ29uZmlnIiwicmVzaXplQ29uZmlnIiwicG9zaXRpb24iLCJleHRyYWN0SGVpZ2h0RnJvbUltYWdlIiwic2hhcnBNZXRhZGF0YSIsInBhZ2VzIiwiY29uZmlnIiwiZmlsZSIsInJlcSIsInNhdmVkRmlsZW5hbWUiLCJzdGF0aWNQYXRoIiwidXBsb2FkRWRpdHMiLCJmb2NhbFBvaW50IiwiZm9jYWxQb2ludEVuYWJsZWQiLCJpbWFnZVNpemVzIiwidXBsb2FkIiwiaW5jb21pbmdGb2NhbFBvaW50IiwieCIsIk1hdGgiLCJyb3VuZCIsInkiLCJkZWZhdWx0UmVzdWx0IiwiZmlsZUlzQW5pbWF0ZWRUeXBlIiwiaW5jbHVkZXMiLCJtaW1ldHlwZSIsInNoYXJwT3B0aW9ucyIsImFuaW1hdGVkIiwic2hhcnBCYXNlIiwic2hhcnAiLCJ0ZW1wRmlsZVBhdGgiLCJkYXRhIiwicm90YXRlIiwib3JpZ2luYWxJbWFnZU1ldGEiLCJtZXRhZGF0YSIsInJlc2l6ZUltYWdlTWV0YSIsInJlc3VsdHMiLCJQcm9taXNlIiwiYWxsIiwibWFwIiwicmVzaXplQWN0aW9uIiwiQm9vbGVhbiIsImltYWdlVG9SZXNpemUiLCJjbG9uZSIsInJlc2l6ZWQiLCJyZXNpemVIZWlnaHQiLCJyZXNpemVXaWR0aCIsInJlc2l6ZUFzcGVjdFJhdGlvIiwicHJpb3JpdGl6ZUhlaWdodCIsInJlc2l6ZSIsImluZm8iLCJ0b0J1ZmZlciIsInJlc29sdmVXaXRoT2JqZWN0IiwiaGFsZlJlc2l6ZVgiLCJ4Rm9jYWxDZW50ZXIiLCJjYWxjdWxhdGVkUmlnaHRQaXhlbEJvdW5kIiwibGVmdEJvdW5kIiwiaGFsZlJlc2l6ZVkiLCJ5Rm9jYWxDZW50ZXIiLCJjYWxjdWxhdGVkQm90dG9tUGl4ZWxCb3VuZCIsInRvcEJvdW5kIiwiZXh0cmFjdCIsImxlZnQiLCJmbG9vciIsInRvcCIsImZvcm1hdE9wdGlvbnMiLCJ0b0Zvcm1hdCIsImZvcm1hdCIsIm9wdGlvbnMiLCJ0cmltT3B0aW9ucyIsInRyaW0iLCJidWZmZXJEYXRhIiwiYnVmZmVySW5mbyIsInNhbml0aXplZEltYWdlIiwicGF5bG9hZFVwbG9hZFNpemVzIiwibWltZUluZm8iLCJmcm9tQnVmZmVyIiwiaW1hZ2VOYW1lV2l0aERpbWVuc2lvbnMiLCJpbWFnZVBhdGgiLCJmaWxlRXhpc3RzIiwiZnMiLCJ1bmxpbmtTeW5jIiwic2l6ZSIsIm1pbWUiLCJidWZmZXIiLCJwYXRoIiwicmVkdWNlIiwiYWNjIiwicmVzdWx0IiwiT2JqZWN0IiwiYXNzaWduIiwicHVzaCJdLCJyYW5nZU1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7IiwibWFwcGluZ3MiOiI7Ozs7K0JBeVBBOzs7Ozs7Ozs7Ozs7O0NBYUMsR0FDRDs7O2VBQThCQTs7OzBCQXBRSDsyREFDWjt5RUFDTTs4REFDSDswQkFhTzttRUFDRjs7Ozs7O0FBeUJ2Qjs7Ozs7Q0FLQyxHQUNELE1BQU1DLHdCQUF3QixDQUFDQztJQUM3QixNQUFNQyxZQUFZRCxZQUFZRSxLQUFLLENBQUMsS0FBS0MsR0FBRztJQUM1QyxNQUFNQyxPQUFPQyxJQUFBQSx5QkFBUSxFQUFDTCxZQUFZTSxTQUFTLENBQUMsR0FBR04sWUFBWU8sV0FBVyxD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